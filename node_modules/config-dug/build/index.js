"use strict";
/* eslint-disable unicorn/no-nested-ternary */
/* eslint-disable no-console */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadConfig = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const get_secret_1 = __importDefault(require("./get-secret"));
const validate_config_1 = require("./validate-config");
const debug = (0, debug_1.default)('config-dug');
const resolveFile = (appDirectory, configPath, fileName) => {
    if (fs_1.default.existsSync(path_1.default.resolve(appDirectory, configPath, `${fileName}.ts`))) {
        debug('resolved config file', fileName, path_1.default.resolve(appDirectory, configPath, `${fileName}.ts`));
        return path_1.default.resolve(appDirectory, configPath, `${fileName}.ts`);
    }
    else if (fs_1.default.existsSync(path_1.default.resolve(appDirectory, configPath, `${fileName}.js`))) {
        debug('resolved config file', fileName, path_1.default.resolve(appDirectory, configPath, `${fileName}.js`));
        return path_1.default.resolve(appDirectory, configPath, `${fileName}.js`);
    }
    else {
        debug('unable to resolve config file', fileName);
        return;
    }
};
const loadFile = (filePath) => {
    if (filePath) {
        debug('loading config file', filePath);
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const config = require(filePath);
            if (filePath.match(/config.+local/)) {
                const fileName = filePath.split('/').pop();
                console.log(`WARNING: Found a local config file ${fileName}`);
            }
            return config.default ? config.default : config;
        }
        catch (error) {
            console.error(`ERROR: Unable to load config file: ${filePath}`);
            console.error(error);
        }
    }
};
const convertString = (value) => {
    if (value.toLowerCase() === 'true')
        return true;
    if (value.toLowerCase() === 'false')
        return false;
    if (value.match(/^\d+\.\d+$/))
        return Number.parseFloat(value);
    if (value.match(/^\d+$/))
        return Number.parseInt(value, 10);
    return value;
};
const convertToArray = (value) => {
    return value
        .split(',')
        .map((entry) => entry.trim())
        .filter((entry) => !!entry);
};
const loadSecrets = (config, overrides) => {
    const secretNames = overrides.AWS_SECRETS_MANAGER_NAMES ||
        config.AWS_SECRETS_MANAGER_NAMES ||
        config.awsSecretsManagerNames;
    const secretName = overrides.AWS_SECRETS_MANAGER_NAME ||
        config.AWS_SECRETS_MANAGER_NAME ||
        config.awsSecretsManagerName;
    const region = overrides.AWS_SECRETS_MANAGER_REGION ||
        config.AWS_SECRETS_MANAGER_REGION ||
        config.awsSecretsManagerRegion ||
        'us-east-1';
    const timeout = overrides.AWS_SECRETS_MANAGER_TIMEOUT ||
        config.AWS_SECRETS_MANAGER_TIMEOUT ||
        config.awsSecretsManagerTimeout ||
        5000;
    const mergedSecretNames = new Set();
    if (secretName) {
        mergedSecretNames.add(secretName);
    }
    if (secretNames) {
        convertToArray(secretNames).forEach((secretName) => {
            mergedSecretNames.add(secretName);
        });
    }
    const secrets = [...mergedSecretNames].map((name) => {
        debug('loading config from AWS Secrets Manager', name, region);
        return (0, get_secret_1.default)(name, region, timeout);
    });
    const mergedSecrets = {};
    secrets.forEach((secret) => {
        Object.assign(mergedSecrets, secret);
    });
    // eslint-disable-next-line unicorn/no-reduce
    return Object.entries(mergedSecrets).reduce((result, [key, value]) => {
        result[key] = convertString(value);
        return result;
    }, {});
};
const loadEnvironment = () => {
    debug('loading config from environment variables');
    // eslint-disable-next-line unicorn/no-reduce
    return Object.entries(process.env).reduce((result, [key, value]) => {
        result[key] = convertString(value);
        return result;
    }, {});
};
const loadConfig = (configPath = '') => {
    const appDirectory = fs_1.default.realpathSync(process.cwd());
    const environment = process.env.APP_ENV
        ? process.env.APP_ENV
        : process.env.NODE_ENV
            ? process.env.NODE_ENV
            : 'development';
    debug('loading config from', path_1.default.resolve(appDirectory, configPath));
    const defaultConfig = loadFile(resolveFile(appDirectory, configPath, 'config.default'));
    const environmentConfig = loadFile(resolveFile(appDirectory, configPath, `config.${environment}`));
    const localEnvironmentConfig = loadFile(resolveFile(appDirectory, configPath, `config.${environment}.local`));
    const localConfig = loadFile(resolveFile(appDirectory, configPath, 'config.local'));
    const fileConfig = Object.assign({}, defaultConfig, environmentConfig, localEnvironmentConfig, localConfig);
    const environmentVars = loadEnvironment();
    const config = Object.assign({}, fileConfig, loadSecrets(fileConfig, environmentVars), environmentVars);
    if (environment === 'test' || environment === 'development') {
        return config;
    }
    else {
        return (0, validate_config_1.validateConfig)(config);
    }
};
exports.loadConfig = loadConfig;
const init = () => {
    debug('loading default config');
    const config = loadConfig();
    return config;
};
exports.default = init();
//# sourceMappingURL=index.js.map